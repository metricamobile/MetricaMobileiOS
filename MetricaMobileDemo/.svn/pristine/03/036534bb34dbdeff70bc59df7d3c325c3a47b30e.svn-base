

#import <CrashReporter/CrashReporter.h>
#import <SystemConfiguration/SystemConfiguration.h>
#import <UIKit/UIKit.h>
#import "MetricaMobileManager.h"
#import "MetricaMobile_OpenUDID.h"
#import <CoreTelephony/CTTelephonyNetworkInfo.h>
#import <CoreTelephony/CTCarrier.h>


#include <sys/types.h>
#include <sys/sysctl.h>
#include <inttypes.h> //needed for PRIx64 macro

#define SDK_NAME @"MetricaMobile"
#define SDK_VERSION @"1.0.5"
#define SDK_HOST @"http://metricamobile.com.br/data"

#define METRICAMOBILE_DEBUG 0

#if METRICAMOBILE_DEBUG
#   define METRICAMOBILE_LOG(fmt, ...) NSLog(fmt, ##__VA_ARGS__)
#else
#   define METRICAMOBILE_LOG(...)
#endif

#define METRICAMOBILE_VERSION SDK_VERSION


@interface DeviceInfo : NSObject
{
}
@end

@implementation DeviceInfo

+ (NSString *)udid
{
	return [MetricaMobile_OpenUDID value];
}

+ (NSString *)device
{
    size_t size;
    sysctlbyname("hw.machine", NULL, &size, NULL, 0);
    char *machine = malloc(size);
    sysctlbyname("hw.machine", machine, &size, NULL, 0);
    NSString *platform = [NSString stringWithUTF8String:machine];
    free(machine);
    return platform;
}

+ (NSString *)model
{
    size_t size;
    sysctlbyname("hw.model", NULL, &size, NULL, 0);
    char *machine = malloc(size);
    sysctlbyname("hw.model", machine, &size, NULL, 0);
    NSString *platform = [NSString stringWithUTF8String:machine];
    free(machine);
    return platform;
}

+ (NSString *)osVersion
{
	return [[UIDevice currentDevice] systemVersion];
}

+ (NSString *)carrier
{
	if (NSClassFromString(@"CTTelephonyNetworkInfo"))
	{
		CTTelephonyNetworkInfo *netinfo = [[CTTelephonyNetworkInfo alloc]init];
		CTCarrier *carrier = [netinfo subscriberCellularProvider];
		return [carrier carrierName];
	}
    
	return nil;
}

+ (NSString *)resolution
{
	CGRect bounds = [[UIScreen mainScreen] bounds];
	CGFloat scale = [[UIScreen mainScreen] respondsToSelector:@selector(scale)] ? [[UIScreen mainScreen] scale] : 1.f;
	CGSize res = CGSizeMake(bounds.size.width * scale, bounds.size.height * scale);
	NSString *result = [NSString stringWithFormat:@"%gx%g", res.width, res.height];
    
	return result;
}

+ (NSString *)locale
{
	return [[NSLocale currentLocale] localeIdentifier];
}

+ (NSString *)metrics
{
	NSString *result = @"{";
    
	result = [result stringByAppendingFormat:@"\"%@\":\"%@\"", @"_device", [DeviceInfo device]];
    
    result = [result stringByAppendingFormat:@",\"%@\":\"%@\"", @"_model", [DeviceInfo model]];
    
	result = [result stringByAppendingFormat:@",\"%@\":\"%@\"", @"_os", @"iOS"];
    
	result = [result stringByAppendingFormat:@",\"%@\":\"%@\"", @"_os_version", [DeviceInfo osVersion]];
    
	NSString *carrier = [DeviceInfo carrier];
	if (carrier != nil)
		result = [result stringByAppendingFormat:@",\"%@\":\"%@\"", @"_carrier", carrier];
    
	result = [result stringByAppendingFormat:@",\"%@\":\"%@\"", @"_resolution", [DeviceInfo resolution]];
    
	result = [result stringByAppendingFormat:@",\"%@\":\"%@\"", @"_locale", [DeviceInfo locale]];
    
	result = [result stringByAppendingString:@"}"];
    
	result = [result stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
    
	return result;
}

@end

@interface ConnectionQueue : NSObject
{
	NSMutableArray *queue_;
	NSURLConnection *connection_;
	UIBackgroundTaskIdentifier bgTask_;
	NSString *appKey;
	NSString *appHost;
}

@property (nonatomic, copy) NSString *appKey;
@property (nonatomic, copy) NSString *appHost;

@end

static ConnectionQueue *s_sharedConnectionQueue = nil;

@implementation ConnectionQueue : NSObject

@synthesize appKey;
@synthesize appHost;

+ (ConnectionQueue *)sharedInstance
{
	if (s_sharedConnectionQueue == nil)
		s_sharedConnectionQueue = [[ConnectionQueue alloc] init];
    
	return s_sharedConnectionQueue;
}

- (id)init
{
	if (self = [super init])
	{
		queue_ = [[NSMutableArray alloc] init];
		connection_ = nil;
        bgTask_ = UIBackgroundTaskInvalid;
        appKey = nil;
        appHost = SDK_HOST;
	}
	return self;
}

- (void) tick
{
    if (connection_ != nil || bgTask_ != UIBackgroundTaskInvalid || [queue_ count] == 0)
        return;
    
    UIApplication *app = [UIApplication sharedApplication];
    bgTask_ = [app beginBackgroundTaskWithExpirationHandler:^{
		[app endBackgroundTask:bgTask_];
		bgTask_ = UIBackgroundTaskInvalid;
    }];
    
    NSString *data = [queue_ objectAtIndex:0];
    NSString *urlString = [NSString stringWithFormat:@"%@/i?%@", self.appHost, data];
    NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:urlString]];
    connection_ = [NSURLConnection connectionWithRequest:request delegate:self];
}

- (void)beginSession
{
	NSString *data = [NSString stringWithFormat:@"app_key=%@&device_id=%@&sdk_version="METRICAMOBILE_VERSION"&begin_session=1&metrics=%@",
					  appKey,
					  [DeviceInfo udid],
					  [DeviceInfo metrics]];
	[queue_ addObject:data];
	[self tick];
}

- (void)updateSessionWithDuration:(int)duration
{
	NSString *data = [NSString stringWithFormat:@"app_key=%@&device_id=%@&session_duration=%d", appKey, [DeviceInfo udid], duration];
	[queue_ addObject:data];
	[self tick];
}

- (void)endSessionWithDuration:(int)duration
{
	NSString *data = [NSString stringWithFormat:@"app_key=%@&device_id=%@&end_session=1&session_duration=%d", appKey, [DeviceInfo udid], duration];
	[queue_ addObject:data];
	[self tick];
}

- (void)connectionDidFinishLoading:(NSURLConnection *)connection
{
	METRICAMOBILE_LOG(@"ok -> %@", [queue_ objectAtIndex:0]);
    
    UIApplication *app = [UIApplication sharedApplication];
    if (bgTask_ != UIBackgroundTaskInvalid)
    {
        [app endBackgroundTask:bgTask_];
        bgTask_ = UIBackgroundTaskInvalid;
    }
    
    connection_ = nil;
    
    [queue_ removeObjectAtIndex:0];
    
    [self tick];
}

- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)err
{
	METRICAMOBILE_LOG(@"error -> %@", [queue_ objectAtIndex:0]);
    
    UIApplication *app = [UIApplication sharedApplication];
    if (bgTask_ != UIBackgroundTaskInvalid)
    {
        [app endBackgroundTask:bgTask_];
        bgTask_ = UIBackgroundTaskInvalid;
    }
    
    connection_ = nil;
}

- (void)dealloc
{
	
	if (connection_)
		[connection_ cancel];
    
	[super dealloc];
}

@end

NSBundle *metricaMobileBundle(void) {
  static NSBundle* bundle = nil;
  if (!bundle) {
    NSString* path = [[[NSBundle mainBundle] resourcePath]
                      stringByAppendingPathComponent:kMetricaMobileBundleName];
    bundle = [[NSBundle bundleWithPath:path] retain];
  }
  return bundle;
}

NSString *BWMetricaMobileLocalize(NSString *stringToken) {
  if ([BWMetricaMobileManager sharedMetricaMobileManager].languageStyle == nil)
    return NSLocalizedStringFromTableInBundle(stringToken, @"MetricaMobile", metricaMobileBundle(), @"");
  else {
    NSString *alternate = [NSString stringWithFormat:@"MetricaMobile%@", [BWMetricaMobileManager sharedMetricaMobileManager].languageStyle];
    return NSLocalizedStringFromTableInBundle(stringToken, alternate, metricaMobileBundle(), @"");
  }
}

@interface BWMetricaMobileManager ()

- (void)startManager;

- (void)showCrashStatusMessage;

- (void)handleCrashReport;
- (void)_cleanCrashReports;

- (void)_checkForFeedbackStatus;

- (void)_performSendingCrashReports;
- (void)_sendCrashReports;

- (void)_postXML:(NSString*)xml toURL:(NSURL*)url;
- (NSString *)_getDevicePlatform;

- (BOOL)hasNonApprovedCrashReports;
- (BOOL)hasPendingCrashReport;

@property (nonatomic, retain) NSFileManager *fileManager;

@end

@implementation BWMetricaMobileManager

@synthesize delegate = _delegate;
@synthesize submissionURL = _submissionURL;
@synthesize showAlwaysButton = _showAlwaysButton;
@synthesize feedbackActivated = _feedbackActivated;
@synthesize autoSubmitCrashReport = _autoSubmitCrashReport;
@synthesize languageStyle = _languageStyle;
@synthesize didCrashInLastSession = _didCrashInLastSession;
@synthesize loggingEnabled = _loggingEnabled;

@synthesize appIdentifier = _appIdentifier;

@synthesize fileManager = _fileManager;

#if __IPHONE_OS_VERSION_MIN_REQUIRED >= 40000
+(BWMetricaMobileManager *)sharedMetricaMobileManager {
  static BWMetricaMobileManager *sharedInstance = nil;
  static dispatch_once_t pred;
  
  dispatch_once(&pred, ^{
    sharedInstance = [BWMetricaMobileManager alloc];
    sharedInstance = [sharedInstance init];
  });
  
  return sharedInstance;
}
#else
+ (BWMetricaMobileManager *)sharedMetricaMobileManager {
  static BWMetricaMobileManager *metricaMobileManager = nil;
	
  if (metricaMobileManager == nil) {
    metricaMobileManager = [[BWMetricaMobileManager alloc] init];
  }
	
  return metricaMobileManager;
}
#endif

- (id) init {
  if ((self = [super init])) {
     //Stadistics: Start
      timer = nil;
      isSuspended = NO;
      unsentSessionLength = 0;
      
      [[NSNotificationCenter defaultCenter] addObserver:self 
                                               selector:@selector(didEnterBackgroundCallBack:) 
                                                   name:UIApplicationDidEnterBackgroundNotification 
                                                 object:nil];
      [[NSNotificationCenter defaultCenter] addObserver:self 
                                               selector:@selector(willEnterForegroundCallBack:) 
                                                   name:UIApplicationWillEnterForegroundNotification 
                                                 object:nil];
      [[NSNotificationCenter defaultCenter] addObserver:self 
                                               selector:@selector(willTerminateCallBack:) 
                                                   name:UIApplicationWillTerminateNotification 
                                                 object:nil];
      
    
      
      //End Stadistics
    _serverResult = CrashReportStatusUnknown;
    _crashIdenticalCurrentVersion = YES;
    _crashData = nil;
    _urlConnection = nil;
    _submissionURL = nil;
    _responseData = nil;
    _appIdentifier = nil;
    _sendingInProgress = NO;
    _languageStyle = nil;
    _didCrashInLastSession = NO;
    _loggingEnabled = YES;
    _fileManager = [[NSFileManager alloc] init];
    
    self.delegate = nil;
    self.feedbackActivated = NO;
    self.showAlwaysButton = NO;
    self.autoSubmitCrashReport = YES;
    
    NSString *testValue = [[NSUserDefaults standardUserDefaults] stringForKey:kMetricaMobileKitAnalyzerStarted];
    if (testValue) {
      _analyzerStarted = [[NSUserDefaults standardUserDefaults] integerForKey:kMetricaMobileKitAnalyzerStarted];
    } else {
      _analyzerStarted = 0;		
    }
		
    testValue = nil;
    testValue = [[NSUserDefaults standardUserDefaults] stringForKey:kMetricaMobileKitActivated];
    if (testValue) {
      _crashReportActivated = [[NSUserDefaults standardUserDefaults] boolForKey:kMetricaMobileKitActivated];
    } else {
      _crashReportActivated = YES;
      [[NSUserDefaults standardUserDefaults] setValue:[NSNumber numberWithBool:YES] forKey:kMetricaMobileKitActivated];
    }
    
    if (_crashReportActivated) {
      _crashFiles = [[NSMutableArray alloc] init];
      NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
      _crashesDir = [[NSString stringWithFormat:@"%@", [[paths objectAtIndex:0] stringByAppendingPathComponent:@"/crashes/"]] retain];
			
      if (![self.fileManager fileExistsAtPath:_crashesDir]) {
        NSDictionary *attributes = [NSDictionary dictionaryWithObject: [NSNumber numberWithUnsignedLong: 0755] forKey: NSFilePosixPermissions];
        NSError *theError = NULL;
				
        [self.fileManager createDirectoryAtPath:_crashesDir withIntermediateDirectories: YES attributes: attributes error: &theError];
      }
      
      PLCrashReporter *crashReporter = [PLCrashReporter sharedReporter];
      NSError *error = NULL;
      
      // Check if we previously crashed
      if ([crashReporter hasPendingCrashReport]) {
        _didCrashInLastSession = YES;
        [self handleCrashReport];
      }
      
      // Enable the Crash Reporter
      if (![crashReporter enableCrashReporterAndReturnError: &error])
        NSLog(@"WARNING: Could not enable crash reporter: %@", error);
      
      [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(startManager) name:BWMetricaMobileNetworkBecomeReachable object:nil];
    }
    
    if (!metricaMobileBundle()) {
      NSLog(@"WARNING: MetricaMobile.bundle is missing, will send reports automatically!");
    }
      
  }
    
  return self;
}
//Stadistics: Start
- (void)start:(NSString *)appKey
{
	timer = [NSTimer scheduledTimerWithTimeInterval:30.0
											 target:self
										   selector:@selector(onTimer:)
										   userInfo:nil
											repeats:YES];
	lastTime = CFAbsoluteTimeGetCurrent();
	[[ConnectionQueue sharedInstance] setAppKey:appKey];
	[[ConnectionQueue sharedInstance] beginSession];
    
    NSString *submissionURL=[NSString stringWithFormat:@"%@/i?aid=%@",SDK_HOST,appKey];
    [self setSubmissionURL:submissionURL];
    submissionURL=nil;
}
- (void)start:(NSString *)appKey withHost:(NSString *)appHost
{
	timer = [NSTimer scheduledTimerWithTimeInterval:30.0
											 target:self
										   selector:@selector(onTimer:)
										   userInfo:nil
											repeats:YES];
	lastTime = CFAbsoluteTimeGetCurrent();
	[[ConnectionQueue sharedInstance] setAppKey:appKey];
	[[ConnectionQueue sharedInstance] setAppHost:appHost];
	[[ConnectionQueue sharedInstance] beginSession];
}
- (void)onTimer:(NSTimer *)timer
{
	if (isSuspended == YES)
		return;
    
	double currTime = CFAbsoluteTimeGetCurrent();
	unsentSessionLength += currTime - lastTime;
	lastTime = currTime;
    
	int duration = unsentSessionLength;
	[[ConnectionQueue sharedInstance] updateSessionWithDuration:duration];
	unsentSessionLength -= duration;
}
- (void)suspend
{
	isSuspended = YES;
    
	double currTime = CFAbsoluteTimeGetCurrent();
	unsentSessionLength += currTime - lastTime;
    
	int duration = unsentSessionLength;
	[[ConnectionQueue sharedInstance] endSessionWithDuration:duration];
	unsentSessionLength -= duration;
}
- (void)resume
{
	lastTime = CFAbsoluteTimeGetCurrent();
    
	[[ConnectionQueue sharedInstance] beginSession];
    
	isSuspended = NO;
}
- (void)exit
{
}

//Stadistics: End

- (void) dealloc {
  self.delegate = nil;
  [[NSNotificationCenter defaultCenter] removeObserver:self name:BWMetricaMobileNetworkBecomeReachable object:nil];

  
  [_languageStyle release];
  
  [_submissionURL release];
  _submissionURL = nil;
  
  [_appIdentifier release];
  _appIdentifier = nil;
  
  [_urlConnection cancel];
  [_urlConnection release]; 
  _urlConnection = nil;
  
  [_crashData release];
  
  [_crashesDir release];
  [_crashFiles release];
  
  [_fileManager release];
  _fileManager = nil;
    //Stadistics: Start
    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationDidEnterBackgroundNotification object:nil];
    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationWillEnterForegroundNotification object:nil];
    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationWillTerminateNotification object:nil];
    if(timer) 
	{
		[timer invalidate];
		timer = nil;
	}
    //Stadistics: End
  
  [super dealloc];
}
//Stadistics: Start
- (void)didEnterBackgroundCallBack:(NSNotification *)notification
{
	METRICAMOBILE_LOG(@"MetricaMobile didEnterBackgroundCallBack");
	[self suspend];
    
}

- (void)willEnterForegroundCallBack:(NSNotification *)notification
{
	METRICAMOBILE_LOG(@"MetricaMobile willEnterForegroundCallBack");
	[self resume];
}

- (void)willTerminateCallBack:(NSNotification *)notification
{
	METRICAMOBILE_LOG(@"MetricaMobile willTerminateCallBack");
	[self exit];
}
//Stadistics: End
#pragma mark -
#pragma mark setter
- (void)setSubmissionURL:(NSString *)anSubmissionURL {
  if (_submissionURL != anSubmissionURL) {
    [_submissionURL release];
    _submissionURL = [anSubmissionURL copy];
  }
  
  [self performSelector:@selector(startManager) withObject:nil afterDelay:1.0f];
}

- (void)setAppIdentifier:(NSString *)anAppIdentifier {    
  if (_appIdentifier != anAppIdentifier) {
    [_appIdentifier release];
    _appIdentifier = [anAppIdentifier copy];
  }
  
  [self setSubmissionURL:@"http://metricamobile.com.br/data/i/"];
}


#pragma mark -
#pragma mark private methods

- (BOOL)autoSendCrashReports {
  BOOL result = NO;
  
  if (!self.autoSubmitCrashReport) {
    if (self.isShowingAlwaysButton && [[NSUserDefaults standardUserDefaults] boolForKey: kAutomaticallySendCrashReports]) {
      result = YES;
    }
  } else {
    result = YES;
  }
  
  return result;
}

// begin the startup process
- (void)startManager {
  if (!_sendingInProgress && [self hasPendingCrashReport]) {
    _sendingInProgress = YES;
    if (!metricaMobileBundle()) {
			NSLog(@"WARNING: MetricaMobile.bundle is missing, sending reports automatically!");
      [self _sendCrashReports];
    } else if (![self autoSendCrashReports] && [self hasNonApprovedCrashReports]) {
      
      if (self.delegate != nil && [self.delegate respondsToSelector:@selector(willShowSubmitCrashReportAlert)]) {
        [self.delegate willShowSubmitCrashReportAlert];
      }
      
      NSString *appName = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleDisplayName"];
      
      UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:[NSString stringWithFormat:BWMetricaMobileLocalize(@"CrashDataFoundTitle"), appName]
                                                          message:[NSString stringWithFormat:BWMetricaMobileLocalize(@"CrashDataFoundDescription"), appName]
                                                         delegate:self
                                                cancelButtonTitle:BWMetricaMobileLocalize(@"CrashDontSendReport")
                                                otherButtonTitles:BWMetricaMobileLocalize(@"CrashSendReport"), nil];
      
      if ([self isShowingAlwaysButton]) {
        [alertView addButtonWithTitle:BWMetricaMobileLocalize(@"CrashSendReportAlways")];
      }
      
      [alertView setTag: MetricaMobileKitAlertTypeSend];
      [alertView show];
      [alertView release];
    } else {
      [self _sendCrashReports];
    }
  }
}

- (BOOL)hasNonApprovedCrashReports {
  NSDictionary *approvedCrashReports = [[NSUserDefaults standardUserDefaults] dictionaryForKey: kApprovedCrashReports];
  
  if (!approvedCrashReports || [approvedCrashReports count] == 0) return YES;
  
  for (NSUInteger i=0; i < [_crashFiles count]; i++) {
    NSString *filename = [_crashFiles objectAtIndex:i];
    
    if (![approvedCrashReports objectForKey:filename]) return YES;
  }
  
  return NO;
}

- (BOOL)hasPendingCrashReport {
  if (_crashReportActivated) {
    if ([_crashFiles count] == 0 && [self.fileManager fileExistsAtPath:_crashesDir]) {
      NSString *file = nil;
      NSError *error = NULL;
      
      NSDirectoryEnumerator *dirEnum = [self.fileManager enumeratorAtPath: _crashesDir];
			
      while ((file = [dirEnum nextObject])) {
        NSDictionary *fileAttributes = [self.fileManager attributesOfItemAtPath:[_crashesDir stringByAppendingPathComponent:file] error:&error];
        if ([[fileAttributes objectForKey:NSFileSize] intValue] > 0) {
          [_crashFiles addObject:file];
        }
      }
    }
    
    if ([_crashFiles count] > 0) {
      BWMetricaMobileLog(@"Pending crash reports found.");
      return YES;
    } else
      return NO;
  } else
    return NO;
}


- (void) showCrashStatusMessage {
  UIAlertView *alertView = nil;
	
  if (_serverResult >= CrashReportStatusAssigned && 
    _crashIdenticalCurrentVersion &&
    metricaMobileBundle()) {
    // show some feedback to the user about the crash status
    NSString *appName = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleDisplayName"];
    switch (_serverResult) {
      case CrashReportStatusAssigned:
        alertView = [[UIAlertView alloc] initWithTitle: [NSString stringWithFormat:BWMetricaMobileLocalize(@"CrashResponseTitle"), appName ]
                                               message: [NSString stringWithFormat:BWMetricaMobileLocalize(@"CrashResponseNextRelease"), appName]
                                              delegate: self
                                     cancelButtonTitle: BWMetricaMobileLocalize(@"CrashResponseTitleOK")
                                     otherButtonTitles: nil];
        break;
      case CrashReportStatusSubmitted:
        alertView = [[UIAlertView alloc] initWithTitle: [NSString stringWithFormat:BWMetricaMobileLocalize(@"CrashResponseTitle"), appName ]
                                               message: [NSString stringWithFormat:BWMetricaMobileLocalize(@"CrashResponseWaitingApple"), appName]
                                              delegate: self
                                     cancelButtonTitle: BWMetricaMobileLocalize(@"CrashResponseTitleOK")
                                     otherButtonTitles: nil];
        break;
      case CrashReportStatusAvailable:
        alertView = [[UIAlertView alloc] initWithTitle: [NSString stringWithFormat:BWMetricaMobileLocalize(@"CrashResponseTitle"), appName ]
                                               message: [NSString stringWithFormat:BWMetricaMobileLocalize(@"CrashResponseAvailable"), appName]
                                              delegate: self
                                     cancelButtonTitle: BWMetricaMobileLocalize(@"CrashResponseTitleOK")
                                     otherButtonTitles: nil];
        break;
      default:
        alertView = nil;
        break;
    }
		
    if (alertView) {
      [alertView setTag: MetricaMobileKitAlertTypeFeedback];
      [alertView show];
      [alertView release];
    }
  }
}


#pragma mark -
#pragma mark UIAlertView Delegate

- (void)alertView:(UIAlertView *)alertView didDismissWithButtonIndex:(NSInteger)buttonIndex {
  if ([alertView tag] == MetricaMobileKitAlertTypeSend) {
    switch (buttonIndex) {
      case 0:
        _sendingInProgress = NO;
        [self _cleanCrashReports];
        break;
      case 1:
        [self _sendCrashReports];
        break;
      case 2: {
        [[NSUserDefaults standardUserDefaults] setBool:YES forKey:kAutomaticallySendCrashReports];
        [[NSUserDefaults standardUserDefaults] synchronize];
        if (self.delegate != nil && [self.delegate respondsToSelector:@selector(userDidChooseSendAlways)]) {
          [self.delegate userDidChooseSendAlways];
        }
        
        [self _sendCrashReports];
        break;
      }
      default:
        _sendingInProgress = NO;
        [self _cleanCrashReports];
        break;
    }
  }
}

#pragma mark -
#pragma mark NSXMLParser Delegate

#pragma mark NSXMLParser

- (void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName attributes:(NSDictionary *)attributeDict {
  if (qName) {
    elementName = qName;
  }
	
  if ([elementName isEqualToString:@"result"]) {
    _contentOfProperty = [NSMutableString string];
  }
}

- (void)parser:(NSXMLParser *)parser didEndElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName {
  if (qName) {
    elementName = qName;
  }
	
  // open source implementation
  if ([elementName isEqualToString: @"result"]) {
    if ([_contentOfProperty intValue] > _serverResult) {
      _serverResult = (CrashReportStatus)[_contentOfProperty intValue];
    } else {
      CrashReportStatus errorcode = (CrashReportStatus)[_contentOfProperty intValue];
      NSLog(@"CrashReporter ended in error code: %i", errorcode);
    }
  }
}


- (void)parser:(NSXMLParser *)parser foundCharacters:(NSString *)string {
  if (_contentOfProperty) {
    // If the current element is one whose content we care about, append 'string'
    // to the property that holds the content of the current element.
    if (string != nil) {
      [_contentOfProperty appendString:string];
    }
  }
}

#pragma mark -
#pragma mark Private


- (NSString *)_getDevicePlatform {
  size_t size = 0;
  sysctlbyname("hw.machine", NULL, &size, NULL, 0);
  char *answer = (char*)malloc(size);
  sysctlbyname("hw.machine", answer, &size, NULL, 0);
  NSString *platform = [NSString stringWithCString:answer encoding: NSUTF8StringEncoding];
  free(answer);
  return platform;
}

- (void)_performSendingCrashReports {
  NSMutableDictionary *approvedCrashReports = [NSMutableDictionary dictionaryWithDictionary:[[NSUserDefaults standardUserDefaults] dictionaryForKey: kApprovedCrashReports]];
  
  NSError *error = NULL;
	
  NSString *userid = @"";
  NSString *contact = @"";
  NSString *description = @"";
  
  if (self.delegate != nil && [self.delegate respondsToSelector:@selector(crashReportUserID)]) {
    userid = [self.delegate crashReportUserID] ?: @"";
  }
	
  if (self.delegate != nil && [self.delegate respondsToSelector:@selector(crashReportContact)]) {
    contact = [self.delegate crashReportContact] ?: @"";
  }
	
  if (self.delegate != nil && [self.delegate respondsToSelector:@selector(crashReportDescription)]) {
    description = [self.delegate crashReportDescription] ?: @"";
  }
	
  NSMutableString *crashes = nil;
  _crashIdenticalCurrentVersion = NO;
  
  for (NSUInteger i=0; i < [_crashFiles count]; i++) {
    NSString *filename = [_crashesDir stringByAppendingPathComponent:[_crashFiles objectAtIndex:i]];
    NSData *crashData = [NSData dataWithContentsOfFile:filename];
		
    if ([crashData length] > 0) {
      PLCrashReport *report = [[[PLCrashReport alloc] initWithData:crashData error:&error] autorelease];
			
      if (report == nil) {
        NSLog(@"Could not parse crash report");
        continue;
      }
      
      NSString *crashLogString = [PLCrashReportTextFormatter stringValueForCrashReport:report withTextFormat:PLCrashReportTextFormatiOS];
      
      if ([report.applicationInfo.applicationVersion compare:[[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleVersion"]] == NSOrderedSame) {
        _crashIdenticalCurrentVersion = YES;
      }
			
      if (crashes == nil) {
        crashes = [NSMutableString string];
      }
      
      [crashes appendFormat:@"<crash><applicationname>%s</applicationname><bundleidentifier>%@</bundleidentifier><systemversion>%@</systemversion><systembuild>%@</systembuild><modelname>%@</modelname><deviceid>%@</deviceid><platform>%@</platform><senderversion>%@</senderversion><version>%@</version><log><![CDATA[%@]]></log><userid>%@</userid><contact>%@</contact><description><![CDATA[%@]]></description></crash>",
       [[[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleExecutable"] UTF8String],
       report.applicationInfo.applicationIdentifier,
       report.systemInfo.operatingSystemVersion,
       report.systemInfo.operatingSystemBuild,
       report.machineInfo.modelName,
       [MetricaMobile_OpenUDID value],
       [self _getDevicePlatform],
       [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleVersion"],
       report.applicationInfo.applicationVersion,
       [crashLogString stringByReplacingOccurrencesOfString:@"]]>" withString:@"]]" @"]]><![CDATA[" @">" options:NSLiteralSearch range:NSMakeRange(0,crashLogString.length)],
       userid,
       contact,
       [description stringByReplacingOccurrencesOfString:@"]]>" withString:@"]]" @"]]><![CDATA[" @">" options:NSLiteralSearch range:NSMakeRange(0,description.length)]];
      
      
      // store this crash report as user approved, so if it fails it will retry automatically
      [approvedCrashReports setObject:[NSNumber numberWithBool:YES] forKey:[_crashFiles objectAtIndex:i]];
    } else {
      // we cannot do anything with this report, so delete it
      [self.fileManager removeItemAtPath:filename error:&error];
    }
  }
	
  [[NSUserDefaults standardUserDefaults] setObject:approvedCrashReports forKey:kApprovedCrashReports];
  [[NSUserDefaults standardUserDefaults] synchronize];
  
  if (crashes != nil) {
    BWMetricaMobileLog(@"Sending crash reports:\n%@", crashes);
    [self _postXML:[NSString stringWithFormat:@"<crashes>%@</crashes>", crashes]
             toURL:[NSURL URLWithString:self.submissionURL]];
    
  }
}

- (void)_cleanCrashReports {
  NSError *error = NULL;
  
  for (NSUInteger i=0; i < [_crashFiles count]; i++) {		
    [self.fileManager removeItemAtPath:[_crashesDir stringByAppendingPathComponent:[_crashFiles objectAtIndex:i]] error:&error];
  }
  [_crashFiles removeAllObjects];
  
  [[NSUserDefaults standardUserDefaults] setObject:nil forKey:kApprovedCrashReports];
  [[NSUserDefaults standardUserDefaults] synchronize];    
}

- (void)_sendCrashReports {
  // send it to the next runloop
  [self performSelector:@selector(_performSendingCrashReports) withObject:nil afterDelay:0.0f];
}

- (void)_checkForFeedbackStatus {
  NSMutableURLRequest *request = nil;
  
  request = [NSMutableURLRequest requestWithURL:
    [NSURL URLWithString:[NSString stringWithFormat:@"%@api/2/apps/%@/crashes/%@",
                          self.submissionURL,
                          [self.appIdentifier stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding],
                          _feedbackRequestID
                          ]
     ]];
  
  [request setCachePolicy: NSURLRequestReloadIgnoringLocalCacheData];
  [request setValue:@"MetricaMobile/iOS" forHTTPHeaderField:@"User-Agent"];
  [request setValue:@"gzip" forHTTPHeaderField:@"Accept-Encoding"];
  [request setTimeoutInterval: 15];
  [request setHTTPMethod:@"GET"];
  
  _serverResult = CrashReportStatusUnknown;
  _statusCode = 200;
	
  // Release when done in the delegate method
  _responseData = [[NSMutableData alloc] init];
	
  if (self.delegate != nil && [self.delegate respondsToSelector:@selector(connectionOpened)]) {
    [self.delegate connectionOpened];
  }
	
  _urlConnection = [[NSURLConnection alloc] initWithRequest:request delegate:self];    
  
  BWMetricaMobileLog(@"Requesting feedback status.");
}

- (void)_postXML:(NSString*)xml toURL:(NSURL*)url {
  NSMutableURLRequest *request = nil;
  NSString *boundary = @"----FOO";
  
  if (self.appIdentifier) {
    request = [NSMutableURLRequest requestWithURL:
               [NSURL URLWithString:[NSString stringWithFormat:@"%@api/2/apps/%@/crashes?sdk=%@&sdk_version=%@",
                                     self.submissionURL,
                                     [self.appIdentifier stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding],
                                     SDK_NAME,
                                     SDK_VERSION
                                     ]
                ]];
  } else {
    request = [NSMutableURLRequest requestWithURL:url];
  }
  
  [request setCachePolicy: NSURLRequestReloadIgnoringLocalCacheData];
  [request setValue:@"MetricaMobile/iOS" forHTTPHeaderField:@"User-Agent"];
  [request setValue:@"gzip" forHTTPHeaderField:@"Accept-Encoding"];
  [request setTimeoutInterval: 15];
  [request setHTTPMethod:@"POST"];
  NSString *contentType = [NSString stringWithFormat:@"multipart/form-data; boundary=%@", boundary];
  [request setValue:contentType forHTTPHeaderField:@"Content-type"];
	
  NSMutableData *postBody =  [NSMutableData data];
  [postBody appendData:[[NSString stringWithFormat:@"--%@\r\n", boundary] dataUsingEncoding:NSUTF8StringEncoding]];
  if (self.appIdentifier) {
    [postBody appendData:[@"Content-Disposition: form-data; name=\"xml\"; filename=\"crash.xml\"\r\n" dataUsingEncoding:NSUTF8StringEncoding]];
    [postBody appendData:[[NSString stringWithFormat:@"Content-Type: text/xml\r\n\r\n"] dataUsingEncoding:NSUTF8StringEncoding]];
  } else {
    [postBody appendData:[@"Content-Disposition: form-data; name=\"xmlstring\"\r\n\r\n" dataUsingEncoding:NSUTF8StringEncoding]];
	}
  [postBody appendData:[xml dataUsingEncoding:NSUTF8StringEncoding]];
  [postBody appendData:[[NSString stringWithFormat:@"\r\n--%@--\r\n", boundary] dataUsingEncoding:NSUTF8StringEncoding]];
  
  [request setHTTPBody:postBody];
	
  _serverResult = CrashReportStatusUnknown;
  _statusCode = 200;
	
  //Release when done in the delegate method
  _responseData = [[NSMutableData alloc] init];
	
  if (self.delegate != nil && [self.delegate respondsToSelector:@selector(connectionOpened)]) {
    [self.delegate connectionOpened];
  }
	
  _urlConnection = [[NSURLConnection alloc] initWithRequest:request delegate:self];
  
  if (!_urlConnection) {
    BWMetricaMobileLog(@"Sending crash reports could not start!");
    _sendingInProgress = NO;
  } else {
    BWMetricaMobileLog(@"Sending crash reports started.");
  }
}

#pragma mark NSURLConnection Delegate

- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response {
  if ([response isKindOfClass:[NSHTTPURLResponse class]]) {
    _statusCode = [(NSHTTPURLResponse *)response statusCode];
  }
}

- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data {
  [_responseData appendData:data];
}

- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error {
  if (self.delegate != nil && [self.delegate respondsToSelector:@selector(connectionClosed)]) {
    [self.delegate connectionClosed];
  }
  
  BWMetricaMobileLog(@"ERROR: %@", [error localizedDescription]);
  
  _sendingInProgress = NO;
  
  [_responseData release];
  _responseData = nil;
  [_urlConnection release];
  _urlConnection = nil;
}

- (void)connectionDidFinishLoading:(NSURLConnection *)connection {
  if (_statusCode >= 200 && _statusCode < 400 && _responseData != nil && [_responseData length] > 0) {
    [self _cleanCrashReports];
    
    _feedbackRequestID = nil;
    if (self.appIdentifier) {
      // MetricaMobileApp uses PList XML format
      NSMutableDictionary *response = [NSPropertyListSerialization propertyListFromData:_responseData
                                                                       mutabilityOption:NSPropertyListMutableContainersAndLeaves
                                                                                 format:nil
                                                                       errorDescription:NULL];
      BWMetricaMobileLog(@"Received API response: %@", response);
      
      _serverResult = (CrashReportStatus)[[response objectForKey:@"status"] intValue];
      if ([response objectForKey:@"id"]) {
        _feedbackRequestID = [[NSString alloc] initWithString:[response objectForKey:@"id"]];
        _feedbackDelayInterval = [[response objectForKey:@"delay"] floatValue];
        if (_feedbackDelayInterval > 0)
          _feedbackDelayInterval *= 0.01;
      }
    } else {
      BWMetricaMobileLog(@"Received API response: %@", [[[NSString alloc] initWithBytes:[_responseData bytes] length:[_responseData length] encoding: NSUTF8StringEncoding] autorelease]);
      
      NSXMLParser *parser = [[NSXMLParser alloc] initWithData:_responseData];
      // Set self as the delegate of the parser so that it will receive the parser delegate methods callbacks.
      [parser setDelegate:self];
      // Depending on the XML document you're parsing, you may want to enable these features of NSXMLParser.
      [parser setShouldProcessNamespaces:NO];
      [parser setShouldReportNamespacePrefixes:NO];
      [parser setShouldResolveExternalEntities:NO];
      
      [parser parse];
      
      [parser release];
    }
    
    if ([self isFeedbackActivated]) {
      // only proceed if the server did not report any problem
      if ((self.appIdentifier) && (_serverResult == CrashReportStatusQueued)) {
        // the report is still in the queue
        if (_feedbackRequestID) {
          [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(_checkForFeedbackStatus) object:nil];
          [self performSelector:@selector(_checkForFeedbackStatus) withObject:nil afterDelay:_feedbackDelayInterval];
        }
      } else {
        [self showCrashStatusMessage];
      }
    }
  } else if (_statusCode == 400 && self.appIdentifier) {
    [self _cleanCrashReports];
    BWMetricaMobileLog(@"ERROR: The server rejected receiving crash reports for this app version!");
  } else {
      BWMetricaMobileLog(@"%@",_responseData);
    if (_responseData == nil || [_responseData length] == 0) {
      BWMetricaMobileLog(@"ERROR: Sending failed with an empty response!");
    } else {
      BWMetricaMobileLog(@"ERROR: Sending failed with status code: %i", _statusCode);
    }
  }
		
  if (self.delegate != nil && [self.delegate respondsToSelector:@selector(connectionClosed)]) {
    [self.delegate connectionClosed];
  }
  
  _sendingInProgress = NO;

  [_responseData release];
  _responseData = nil;
  [_urlConnection release];
  _urlConnection = nil;
}

#pragma mark PLCrashReporter

//
// Called to handle a pending crash report.
//
- (void) handleCrashReport {
  PLCrashReporter *crashReporter = [PLCrashReporter sharedReporter];
  NSError *error = NULL;
	
  // check if the next call ran successfully the last time
  if (_analyzerStarted == 0) {
    // mark the start of the routine
    _analyzerStarted = 1;
    [[NSUserDefaults standardUserDefaults] setValue:[NSNumber numberWithInt:_analyzerStarted] forKey:kMetricaMobileKitAnalyzerStarted];
    [[NSUserDefaults standardUserDefaults] synchronize];
    
    // Try loading the crash report
    _crashData = [[NSData alloc] initWithData:[crashReporter loadPendingCrashReportDataAndReturnError: &error]];
    
    NSString *cacheFilename = [NSString stringWithFormat: @"%.0f", [NSDate timeIntervalSinceReferenceDate]];
    
    if (_crashData == nil) {
      NSLog(@"Could not load crash report: %@", error);
    } else {
      [_crashData writeToFile:[_crashesDir stringByAppendingPathComponent: cacheFilename] atomically:YES];
    }
  }
	
  // Purge the report
  // mark the end of the routine
  _analyzerStarted = 0;
  [[NSUserDefaults standardUserDefaults] setValue:[NSNumber numberWithInt:_analyzerStarted] forKey:kMetricaMobileKitAnalyzerStarted];
  [[NSUserDefaults standardUserDefaults] synchronize];
  
  [crashReporter purgePendingCrashReport];
  return;
}


@end
